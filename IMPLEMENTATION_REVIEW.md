# 実装レビュー（無料運用・技術実現性）

## 結論（先に要点）

- この仕様は **無料枠中心で十分にプロトタイプ実装可能**。
- ただし「完全P2P」はモバイルWebでは制約が多いため、
  **Cloudflare Durable Objects（1ルーム=1オブジェクト）を中継にした準P2P構成**が現実的。
- クライアント主導（前処理をフロントに寄せる）も可能だが、
  **対戦ゲームとしての不正対策・再接続整合性のため、最終判定はサーバー側（DO）に寄せる**べき。
- モバイル展開は、まず **PWAで検証 → 必要ならCapacitorでiOS/Android包む**の順が、
  Windows 11環境での開発コスト最小。

## 1. Cloudflareでの実装可否

### 推奨アーキテクチャ（無料寄り）

- フロント：Cloudflare Pages（静的配信）
- 対戦セッション管理：Cloudflare Workers + Durable Objects
- 同期：WebSocket（DOが部屋状態を保持し、各クライアントへ配信）
- 永続化（任意）：
  - 最小はDOメモリ + スナップショット
  - 必要に応じてD1/KV/R2

### なぜDOが合うか

- ターン制で「単一の正しい状態（SSOT）」が必要
- ルーム単位の排他制御（同時更新の順序保証）が重要
- 7x7盤面 + 手札 + 山札重み抽選はデータ量が小さく、DOで十分

## 2. 「前処理をフロント」に寄せる案の評価

### できること（寄せてOK）

- UI入力チェック（選択可能マスのハイライト）
- 一時的な演出/予測表示（optimistic UI）
- ローカルでの候補手計算

### サーバー側で必須にすべきこと

- 正式なルール判定（移動可否、戦闘、死亡、補充、ドロー）
- 乱数処理（カード抽選、ランダム奪取）
- ターン進行とタイムアウト処理

> 理由：すべてフロント計算にすると改ざん耐性がほぼなく、対戦として成立しにくい。

## 3. P2P（WebRTC）可否

### 結論

- **純P2Pのみで完結**は実務上おすすめしない。
- 実現するとしても、以下が必要：
  - シグナリングサーバー（結局サーバーが必要）
  - TURN（NAT越え。無料運用が難しい/不安定）
  - 切断復帰時の状態同期ロジック

### 代替

- 「通信遅延を抑えたい」目的なら、
  **DO WebSocket中継 + 軽量イベント設計**で十分低遅延。

## 4. 仕様書から見た実装リスク（先に埋めるべき不明点）

実装前に以下を確定すると、後戻りを大幅に減らせる。

1. 召喚不可時の処理（補充召喚フェイズ）
2. 手札上限超過時の処理（破棄？選択破棄？）
3. 山札確率変動ルール（Wの時間変化）
4. 地雷の発動条件/重複時処理/公開情報か否か
5. 「前前」「2マス前進」の向き定義（各プレイヤー基準）
6. 自陣地/敵陣地判定の更新タイミング
7. 同時死亡・連鎖時の解決順序

## 5. 実装ロードマップ（無料で無理なく）

### Phase 1: 縦切りMVP

- 2人対戦ルーム作成/参加
- 盤面表示、1ターン進行
- 主要カード数枚のみ（Move/Assault/Arrowrain/Mine）
- リプレイログ（イベント列）

### Phase 2: ルール完成

- 全Creature/カード
- 抽選重みWと補充ロジック
- 切断復帰、再接続

### Phase 3: 品質

- 観戦/履歴
- レート/マッチング
- 監査ログ・不正検知

## 6. PWA vs ネイティブ（Windows 11前提）

### 推奨順序

1. **PWAで先に公開**（最短・低コスト）
2. 必要なら **CapacitorでiOS/Androidアプリ化**

### Windows 11での現実

- Android：Windowsでもビルド/配布しやすい
- iOS：最終ビルド/署名/配布にはmacOSがほぼ必須
  - 対応策：
    - クラウドMac（有料）
    - 共同開発者のMac

### 判断基準

- プッシュ通知・課金・深いOS連携が不要ならPWAで十分
- App Store配布優先なら早めにCapacitor想定で設計

## 7. コスト観点

- 初期はCloudflare無料枠で開始可能な可能性が高い
- コストが先に増えるのは通常以下：
  - 同時接続数（WebSocket）
  - TURN利用（P2Pを本格化した場合）
  - 高頻度ログ保存

## 8. 具体的な技術選択（最小）

- フロント：React or Svelte + Zustand等
- 共有ロジック：TypeScriptでルールエンジンを共通化
- サーバー：Workers + Durable Objects
- 通信：WebSocket（イベント駆動）
- テスト：
  - ルールのプロパティテスト
  - 再現性あるseed付き乱数テスト

## 最終提案

- あなたの前提（Web経験中心）に最も合うのは、
  **「Cloudflareサーバーレス + authoritative server + PWA先行」**。
- P2Pは「将来の最適化候補」に留め、まずはDO中継でゲーム成立を優先するのが安全。

## 9. ローカルLLM（Ollama / llama.cpp / LM Studio）で
## Ralph Wiggum Loop的に「自動でアプリを作る」ことは可能か

### 結論

- **可能。** ただし「放置で常に完成」ではなく、
  **完了条件・停止条件・検証自動化を先に設計した場合に実用化できる**。
- 特にこのリポジトリのような仕様先行プロジェクトでは、
  Ralph Loopは「実装そのもの」より **タスク分解と検証駆動の運用設計**が成否を分ける。

### 実現イメージ（最小構成）

1. `tasks.json` にタスクと完了条件を宣言
2. ループ実行（ローカルLLMに都度同じ指示を与える）
3. 変更後に自動テスト/静的チェック実行
4. 進捗を `progress.md` / `artifacts/` に保存
5. スコアが閾値を満たしたら停止、未達なら再ループ

### 外部状態として持つべきファイル

- `tasks.json`：タスク一覧、依存関係、完了条件（Yes/No判定可能）
- `loop_state.json`：現在タスク、連続失敗回数、最終エラー
- `progress.md`：人間が朝確認するための要約ログ
- `artifacts/`：テスト結果、差分要約、スクリーンショット

### 安全装置（必須）

- 完了判定の多重化：
  - 例）テスト成功 + 差分あり + 完了JSON出力
- サーキットブレーカー：
  - 連続N回進捗なしで停止
  - 同一エラーM回で停止
  - 変更なしループが続いたら停止
- 破壊防止：
  - 1ループ1コミット（ロールバック容易化）
  - main直push禁止、作業ブランチ固定

### ローカルLLM運用での現実的な制約

- 品質はモデルサイズとコンテキスト長に強く依存
- 長時間ループでは「同じ失敗を繰り返す」現象が起きやすい
- テストが弱いと、誤実装でも完了扱いになる
- GPU/電力コストは無料ではない（API費は抑えられる）

### このゲーム企画への適用優先度

- 向いている工程：
  - 仕様の機械可読化（未確定項目のTODO抽出）
  - テストケース雛形生成
  - UIコンポーネントのたたき台生成
- 向きにくい工程：
  - ゲームルールの最終妥当性判断
  - バランス調整（数値設計）

### 導入順（失敗しにくい順）

1. **半自動**：提案生成のみ（人間マージ必須）
2. **限定自動**：テストが通る小タスクだけ自動コミット
3. **夜間自動**：Ralph Loopで複数タスクを連続処理

### 実務的な一言

- 「寝てる間にPR完成」は、夢物語ではなく **設計次第で部分的に実現可能**。
- ただし成功条件は「高性能モデル」より、
  **細かい完了条件・強いテスト・停止ルール**にある。
