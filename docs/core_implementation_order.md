# Core実装の推奨順序（カード処理を除く）

`core` を「ルールの真実源」として完成させるための、実装順序を定義する。
本ドキュメントは **カード処理をスコープ外** とし、`Ameba / Goblin / Soldier` とターン進行・勝敗判定の完成を目的とする。

## 前提（Done条件）

- `core` は純粋関数で完結し、I/O・乱数・時刻依存を持たない
- ルール変更は `types` / `validate` / `event` / `state遷移` / `テスト` が同時更新される
- backend は `core` の出力（events + state）をそのまま authoritative に扱える

---

## 実装順序

### 1. ドメイン型を先に固定する

最初に `types.ts` を拡張し、以降の実装の土台を固める。

- `CreatureKind`（`Ameba | Goblin | Soldier`）
- Creatureの基本ステータス（`hp`, `at`, `successorCost`）
- 盤面上個体の現在値（`currentHp` を持つか、`hp` を可変とするか方針を統一）
- ターン内状態
  - 例: 「このターン移動済みか」の管理
- フェイズ状態
  - 補充召喚フェイズ → メイン → エンドの最小管理
- ゲーム終了状態
  - `winner` / `status(inProgress|finished)` など

> ここで「状態スキーマ」を固定しないと、後工程（検証・イベント設計・勝敗判定）で再設計コストが増える。

### 2. イベントスキーマを定義する

次に `Event` を増やし、「状態変化を全部イベントで表現」できるようにする。

次ステップ（イベントスキーマ）では次の最小セットが良いです。

- `PieceMoved`（既存）
- `TurnEnded`（既存）
- `CombatResolved`（新規）
- `SuccessorSpawned`（新規）
- `GameFinished`（新規）

これで「必要十分」になり、API往復は増えません。

実装順序としては「まずイベント型定義 → 次に `applyEvent` 対応」が安全。

### 3. Move検証をゲームルール準拠に強化する

`validateIntent` を以下の順で厳密化する。

1. 手番プレイヤー検証（既存）
2. 対象クリーチャー所有者検証（既存）
3. 移動先が8方向1マスか
4. 同一マス滞在の禁止
5. クリーチャー同士の重複禁止
6. ゲーム終了後の操作禁止
7. フェイズ外操作禁止（メインフェイズ以外でMove不可）
8. 1ターン1体1回移動制限

### 4. 移動時の自動戦闘を実装する

`buildEvent/applyCommand` で「移動先に敵がいる場合の自動攻撃」を導入する。

- 攻撃宣言は不要（移動結果で判定）
- 一方攻撃のみ（反撃なし）
- ダメージ = 攻撃側AT
- HPが0以下で死亡イベントを生成

実装上は、1コマンドで複数イベント（移動→ダメージ→死亡）を返せる設計にする。

### 5. 補充召喚ロジックをターン開始処理として追加する

カードなしスコープでも、`Successor cost` を満たす補充は必須。

- 死亡時に「補充待ちキュー」を作る
- ターン開始時（補充召喚フェイズ）にカウントを進める
- `cost=0` 到達で `SuccessorSpawned`
- 召喚位置の決定ルールを純粋関数で確定
  - 例: 自陣地内の先頭空きマス優先（決定的ルール）

※ UI入力に依存する配置選択は後回しにし、まずは決定的配置でcoreを完了させる。

### 6. EndTurnをフェイズ駆動に更新する

`EndTurn` で単純に手番交代する現状から、以下を順番に処理する。

- メイン終了
- 次プレイヤーへ交代
- ターン番号更新
- 次ターンの補充召喚フェイズを実行
- メインフェイズ開始状態へ遷移

### 7. 勝利条件判定を組み込む

各コマンド適用後（またはイベント適用後）に勝敗を判定する。

- ルール仕様に沿った勝利条件を関数化
- 条件成立時は `GameFinished` を生成
- `status=finished` 後は全Intentをreject

### 8. createInitialStateを最小完成状態に更新する

初期盤面を仕様に合わせる。

- 2プレイヤー分の初期クリーチャー構成（Ameba/Goblin/Soldier）
- 初期フェイズ・ターン内フラグ
- 初期陣地データ（必要なら）

### 9. core単体テストを先に揃える

backend統合より先に、`core` のテストで仕様固定する。

- 正常系
  - 1マス移動
  - 移動による自動戦闘
  - 死亡と補充
  - ターンエンド遷移
  - 勝敗確定
- 異常系
  - 手番違反
  - 移動距離違反
  - 重複配置
  - 終局後操作

### 10. backend接続前の受け入れ条件を明文化する

最後に、`core` 完了のチェックリストを置く。

- ルール由来の状態遷移が `applyCommand` だけで再現できる
- 主要分岐をテストで網羅
- `Event` から状態再構築できる（必要ならリプレイテスト）

---

## 実装の進め方（推奨スプリント）

1. **Sprint A**: 手順1〜3（型と検証の土台）
2. **Sprint B**: 手順4〜6（戦闘・補充・ターン進行）
3. **Sprint C**: 手順7〜10（勝敗・初期状態・テスト・完了判定）

この順序なら、backend/frontend 側への影響を最小にしながら `core` を段階的に完成できる。
